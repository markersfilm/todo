import React, { useState, useEffect, useRef, memo } from 'react';
import { 
  CheckSquare, 
  Square, 
  Trash2, 
  Copy, 
  Plus, 
  Clock, 
  Play, 
  Pause, 
  RotateCcw, 
  LayoutGrid, 
  List as ListIcon,
  AlertCircle,
  Star,
  CheckCircle2,
  GripVertical,
  CornerDownRight,
  X,
  Pencil,
  Minus,
  Download, // ì•„ì´ì½˜ ì¬ì‚¬ìš© (í´ë¦½ë³´ë“œ ë³µì‚¬ ì˜ë¯¸ë¡œ)
  Upload,   // ì•„ì´ì½˜ ì¬ì‚¬ìš© (í…ìŠ¤íŠ¸ ë¶™ì—¬ë„£ê¸° ì˜ë¯¸ë¡œ)
  FileText,
  ClipboardCopy,
  ClipboardPaste
} from 'lucide-react';

// --- Extracted & Memoized Components ---

const TaskItem = memo(({ 
  task, 
  toggleTask, 
  deleteTask, 
  updateTask, 
  toggleSubtask, 
  deleteSubtask, 
  updateSubtask, 
  addSubtask, 
  addingSubtaskTo, 
  setAddingSubtaskTo,
  reorderSubtask, 
  onDragStart,
  onDragOver, 
  onDropTask,
  isDraggingSource, 
  draggedType 
}) => {
  const [isEditing, setIsEditing] = useState(false);
  const [editText, setEditText] = useState(task.text);
  const [dropPosition, setDropPosition] = useState(null); 
  const inputRef = useRef(null);
  const subtaskInputRef = useRef(null);
  const itemRef = useRef(null);

  const isAddingSubtask = addingSubtaskTo === task.id;

  useEffect(() => {
    if (isEditing && inputRef.current) {
      inputRef.current.focus();
    }
  }, [isEditing]);

  useEffect(() => {
    if (isAddingSubtask && subtaskInputRef.current) {
      subtaskInputRef.current.focus();
    }
  }, [isAddingSubtask]);

  const startEditing = () => {
    setIsEditing(true);
    setEditText(task.text);
  };

  const saveEdit = () => {
    if (editText.trim()) {
      updateTask(task.id, editText);
    } else {
      setEditText(task.text); 
    }
    setIsEditing(false);
  };

  const handleEditKeyDown = (e) => {
    if (e.nativeEvent.isComposing) return;
    if (e.key === 'Enter') saveEdit();
    if (e.key === 'Escape') {
      setEditText(task.text);
      setIsEditing(false);
    }
  };

  const handleSubtaskSubmit = (e) => {
    if (e.nativeEvent.isComposing) return;
    if (e.key === 'Enter') {
      e.preventDefault();
      const text = e.target.value;
      if (text.trim()) {
        addSubtask(task.id, text);
        e.target.value = ''; 
      }
    }
  };

  // --- Drag & Drop Visual Logic (Main Task) ---
  const handleDragOver = (e) => {
    e.preventDefault();
    e.stopPropagation();
    
    if (!itemRef.current || isDraggingSource || draggedType !== 'task') {
      setDropPosition(null);
      return;
    }

    const rect = itemRef.current.getBoundingClientRect();
    const midY = rect.top + rect.height / 2;
    
    if (e.clientY < midY) {
      setDropPosition('top');
    } else {
      setDropPosition('bottom');
    }
  };

  const handleDragLeave = () => {
    setDropPosition(null);
  };

  const handleDrop = (e) => {
    e.preventDefault();
    e.stopPropagation();
    setDropPosition(null);
    if (draggedType === 'task') {
      onDropTask(e, task, dropPosition);
    }
  };

  const onSubtaskDragStart = (e, subtaskId) => {
    e.stopPropagation(); 
    e.dataTransfer.setData("type", "subtask");
    e.dataTransfer.setData("parentId", task.id);
    e.dataTransfer.setData("subtaskId", subtaskId);
    e.dataTransfer.effectAllowed = "move";
    onDragStart(e, task.id, 'subtask'); 
  };

  const onSubtaskDrop = (e, targetSubtaskId, position) => {
    e.preventDefault();
    e.stopPropagation();
  };

  const commonTextStyle = "text-[15px] font-medium leading-snug px-1 py-0.5 rounded border";

  return (
    <div 
      ref={itemRef}
      draggable={!isEditing}
      onDragStart={(e) => onDragStart(e, task.id, 'task')} 
      onDragOver={handleDragOver}
      onDragLeave={handleDragLeave}
      onDrop={handleDrop}
      className={`group relative flex flex-col p-4 rounded-xl mb-3 transition-all duration-200 border border-transparent ${
        isDraggingSource ? 'opacity-40 bg-gray-100 border-dashed border-gray-300 scale-[0.98]' : 
        task.completed ? 'bg-gray-50/50 opacity-60' : 'bg-white hover:shadow-md shadow-sm hover:border-gray-100'
      }`}
    >
      {dropPosition === 'top' && (
        <div className="absolute -top-2 left-0 right-0 h-1 bg-indigo-500 rounded-full pointer-events-none z-50 shadow-sm ring-2 ring-white transition-all duration-200"></div>
      )}
      {dropPosition === 'bottom' && (
        <div className="absolute -bottom-2 left-0 right-0 h-1 bg-indigo-500 rounded-full pointer-events-none z-50 shadow-sm ring-2 ring-white transition-all duration-200"></div>
      )}

      {/* Top Row */}
      <div className="flex items-start gap-3.5 pointer-events-none"> 
        <div className="mt-1 text-gray-200 group-hover:text-gray-400 transition-colors cursor-grab active:cursor-grabbing shrink-0 pointer-events-auto">
          <GripVertical className="w-4 h-4" />
        </div>

        <button onClick={() => toggleTask(task.id, 'completed')} className="mt-0.5 shrink-0 transition-colors pointer-events-auto">
          {task.completed ? 
            <CheckCircle2 className="w-5 h-5 text-gray-400" /> : 
            <div className="w-5 h-5 rounded-full border-2 border-gray-300 hover:border-indigo-500 transition-colors" />
          }
        </button>
        
        <div className="flex-1 min-w-0 pointer-events-auto">
          {isEditing ? (
            <input
              ref={inputRef}
              type="text"
              value={editText}
              onChange={(e) => setEditText(e.target.value)}
              onBlur={saveEdit}
              onKeyDown={handleEditKeyDown}
              className={`w-full bg-gray-50 focus:outline-none focus:ring-2 focus:ring-indigo-100 text-gray-800 border-transparent ${commonTextStyle}`}
            />
          ) : (
            <span 
              onDoubleClick={startEditing}
              className={`block cursor-default border-transparent ${commonTextStyle} ${task.completed ? 'line-through text-gray-400' : 'text-gray-800'}`}
            >
              {task.text}
            </span>
          )}
        </div>

        <div className="flex items-center gap-1 opacity-0 group-hover:opacity-100 transition-opacity shrink-0 pointer-events-auto">
          <button 
            onClick={() => setAddingSubtaskTo(task.id)}
            title="í•˜ìœ„ í•­ëª© ì¶”ê°€"
            className="p-1.5 text-gray-300 hover:text-indigo-500 hover:bg-indigo-50 rounded-md transition-colors"
          >
            <CornerDownRight className="w-3.5 h-3.5" />
          </button>
          <button 
            onClick={startEditing}
            title="ìˆ˜ì • (ë”ë¸”í´ë¦­)"
            className="p-1.5 text-gray-300 hover:text-blue-500 hover:bg-blue-50 rounded-md transition-colors"
          >
            <Pencil className="w-3.5 h-3.5" />
          </button>
          <button 
            onClick={() => deleteTask(task.id)}
            title="ì‚­ì œ"
            className="p-1.5 text-gray-300 hover:text-red-500 hover:bg-red-50 rounded-md transition-colors"
          >
            <Trash2 className="w-3.5 h-3.5" />
          </button>
        </div>
      </div>

      {/* Subtasks Row */}
      {(task.subtasks?.length > 0 || isAddingSubtask) && (
        <div className="mt-2 space-y-1 ml-[1.875rem]"> 
          {task.subtasks.map(st => (
            <SubtaskItem 
              key={st.id}
              subtask={st}
              parentId={task.id}
              toggleSubtask={toggleSubtask}
              deleteSubtask={deleteSubtask}
              updateSubtask={updateSubtask}
              onDragStart={onSubtaskDragStart}
              onDrop={(e, pos) => reorderSubtask(task.id, parseInt(e.dataTransfer.getData("subtaskId")), st.id, pos)} 
              draggedType={draggedType} 
            />
          ))}
          
          {isAddingSubtask && (
            <div className="flex items-center gap-1 pl-1 py-1 animate-in fade-in slide-in-from-top-1 duration-200 bg-gray-50/50 rounded-lg">
              <div className="w-5 flex justify-center">
                 <CornerDownRight className="w-3.5 h-3.5 text-indigo-300" />
              </div>
              <input
                ref={subtaskInputRef}
                type="text"
                onKeyDown={handleSubtaskSubmit}
                onBlur={() => setAddingSubtaskTo(null)}
                placeholder="í•˜ìœ„ í•­ëª© ì…ë ¥..."
                className="flex-1 bg-transparent text-sm p-1 focus:outline-none text-gray-600 placeholder-gray-300 ime-mode-active"
              />
            </div>
          )}
        </div>
      )}
    </div>
  );
});

const SubtaskItem = memo(({ subtask, parentId, toggleSubtask, deleteSubtask, updateSubtask, onDragStart, onDrop, draggedType }) => {
  const [isEditing, setIsEditing] = useState(false);
  const [text, setText] = useState(subtask.text);
  const [dropPosition, setDropPosition] = useState(null);
  const inputRef = useRef(null);
  const itemRef = useRef(null);

  useEffect(() => {
    if (isEditing && inputRef.current) {
      inputRef.current.focus();
      inputRef.current.setSelectionRange(text.length, text.length);
    }
  }, [isEditing]);

  const save = () => {
    if (text.trim()) updateSubtask(parentId, subtask.id, text);
    else setText(subtask.text);
    setIsEditing(false);
  };

  const handleKeyDown = (e) => {
    if (e.nativeEvent.isComposing) return;
    if (e.key === 'Enter') save();
    if (e.key === 'Escape') {
      setText(subtask.text);
      setIsEditing(false);
    }
  };

  const handleDragOver = (e) => {
    e.preventDefault();
    e.stopPropagation();
    if (!itemRef.current || draggedType !== 'subtask') {
      setDropPosition(null);
      return;
    }

    const rect = itemRef.current.getBoundingClientRect();
    const midY = rect.top + rect.height / 2;
    
    if (e.clientY < midY) {
      setDropPosition('top');
    } else {
      setDropPosition('bottom');
    }
  };

  const handleDragLeave = () => {
    setDropPosition(null);
  };

  const handleDrop = (e) => {
    e.preventDefault();
    e.stopPropagation();
    setDropPosition(null);
    if (draggedType === 'subtask') {
      onDrop(e, dropPosition);
    }
  };

  const subtaskTextStyle = "text-sm focus:outline-none bg-transparent w-full block break-words whitespace-pre-wrap leading-relaxed";

  return (
    <div 
      ref={itemRef}
      draggable={!isEditing}
      onDragStart={(e) => onDragStart(e, subtask.id)}
      onDragOver={handleDragOver}
      onDragLeave={handleDragLeave}
      onDrop={handleDrop}
      className={`flex items-start gap-1 group/sub px-2 py-1.5 rounded-lg cursor-grab active:cursor-grabbing relative transition-colors w-full ${
        isEditing ? 'bg-white ring-2 ring-indigo-100 shadow-sm z-10' : 'hover:bg-gray-100'
      }`}
    >
      {dropPosition === 'top' && (
        <div className="absolute -top-0.5 left-0 right-0 h-0.5 bg-indigo-400 rounded-full pointer-events-none z-50"></div>
      )}
      {dropPosition === 'bottom' && (
        <div className="absolute -bottom-0.5 left-0 right-0 h-0.5 bg-indigo-400 rounded-full pointer-events-none z-50"></div>
      )}

      <div className="mt-1 w-3 h-4 flex-shrink-0 flex items-center justify-center">
        <GripVertical className="w-3 h-3 text-gray-300 opacity-0 group-hover/sub:opacity-100 cursor-grab" />
      </div>
      
      <div className="mt-1 w-4 flex justify-center flex-shrink-0">
        <CornerDownRight className="w-3.5 h-3.5 text-gray-400" />
      </div>
      
      <button onClick={() => toggleSubtask(parentId, subtask.id)} className="mt-0.5 flex-shrink-0">
        {subtask.completed ? 
          <CheckSquare className="w-4 h-4 text-gray-400" /> : 
          <Square className="w-4 h-4 text-gray-300 hover:text-indigo-400" />
        }
      </button>

      <div className="flex-1 min-w-0 ml-1">
        {isEditing ? (
          <textarea 
            ref={inputRef}
            value={text}
            onChange={e => setText(e.target.value)}
            onBlur={save}
            onKeyDown={handleKeyDown}
            rows={1}
            style={{ height: 'auto', minHeight: '24px' }}
            className={`resize-none overflow-hidden ${subtaskTextStyle}`}
            onInput={(e) => {
              e.target.style.height = 'auto';
              e.target.style.height = e.target.scrollHeight + 'px';
            }}
          />
        ) : (
          <span 
            onDoubleClick={() => setIsEditing(true)}
            className={`cursor-default border-transparent ${subtaskTextStyle} ${subtask.completed ? 'line-through text-gray-400' : 'text-gray-600'}`}
          >
            {subtask.text}
          </span>
        )}
      </div>

      <button onClick={() => deleteSubtask(parentId, subtask.id)} className="opacity-0 group-hover/sub:opacity-100 text-gray-300 hover:text-red-400 ml-2 p-0.5 flex-shrink-0">
        <X className="w-3.5 h-3.5" />
      </button>
    </div>
  );
});

const Quadrant = memo(({ 
  id, title, description, tasks, headerColor, icon: Icon, 
  targetUrgent, targetImportant,
  toggleTask, deleteTask, updateTask, toggleSubtask, deleteSubtask, updateSubtask, addSubtask, 
  reorderSubtask,
  addingSubtaskTo, setAddingSubtaskTo, 
  onDragStart, onDragOver, onDropTask, onDropQuadrant,
  draggedTaskId,
  draggedType 
}) => {
  return (
    <div 
      onDragOver={onDragOver}
      onDrop={(e) => onDropQuadrant(e, targetUrgent, targetImportant)}
      className="flex flex-col h-full bg-white rounded-3xl shadow-[0_2px_12px_-4px_rgba(0,0,0,0.05)] border border-gray-100 overflow-hidden hover:shadow-md transition-shadow duration-300"
    >
      <div className="px-6 pt-6 pb-4">
        <div className="flex items-center justify-between mb-1">
          <div className="flex items-center gap-2.5">
            <div className={`p-2 rounded-xl ${headerColor} bg-opacity-10`}>
              <Icon className={`w-4 h-4 ${headerColor.replace('bg-', 'text-')}`} />
            </div>
            <h3 className="font-bold text-gray-800 text-lg tracking-tight">{title}</h3>
          </div>
          <span className="text-xs font-bold px-2.5 py-1 rounded-full bg-gray-50 text-gray-400">
            {tasks.length}
          </span>
        </div>
      </div>

      <div className="flex-1 overflow-y-auto custom-scrollbar px-4 pb-4 min-h-[100px] bg-gray-50/30">
        {tasks.length === 0 ? (
          <div className="h-full flex flex-col items-center justify-center">
            <span className="text-gray-300 text-sm font-medium">ë¹„ì–´ìˆìŒ</span>
          </div>
        ) : (
          <div className="pt-2">
             {tasks.map(t => (
               <TaskItem 
                 key={t.id} 
                 task={t} 
                 toggleTask={toggleTask}
                 deleteTask={deleteTask}
                 updateTask={updateTask}
                 toggleSubtask={toggleSubtask}
                 deleteSubtask={deleteSubtask}
                 updateSubtask={updateSubtask}
                 addSubtask={addSubtask}
                 reorderSubtask={reorderSubtask}
                 addingSubtaskTo={addingSubtaskTo}
                 setAddingSubtaskTo={setAddingSubtaskTo}
                 onDragStart={onDragStart}
                 onDragOver={onDragOver}
                 onDropTask={onDropTask}
                 isDraggingSource={draggedTaskId === t.id}
                 draggedType={draggedType} 
               />
             ))}
          </div>
        )}
      </div>
    </div>
  );
});

// --- Simple Data Import Modal ---
const DataModal = ({ isOpen, onClose, onSave }) => {
  const [textData, setTextData] = useState('');

  if (!isOpen) return null;

  const handleSave = () => {
    if (!textData.trim()) {
      alert("ë¶™ì—¬ë„£ì€ ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.");
      return;
    }
    try {
      const parsed = JSON.parse(textData);
      if (Array.isArray(parsed)) {
        onSave(parsed);
        onClose();
      } else {
        alert("ì˜¬ë°”ë¥¸ ë°ì´í„° í˜•ì‹ì´ ì•„ë‹™ë‹ˆë‹¤. (ë°°ì—´ í˜•ì‹ì´ ì•„ë‹™ë‹ˆë‹¤)");
      }
    } catch (e) {
      alert("ë°ì´í„°ë¥¼ ì½ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. JSON í˜•ì‹ì´ ë§ëŠ”ì§€ í™•ì¸í•´ì£¼ì„¸ìš”.");
    }
  };

  return (
    <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-[100] p-4">
      <div className="bg-white rounded-2xl w-full max-w-lg shadow-2xl p-6 flex flex-col gap-4">
        <div className="flex justify-between items-center">
          <h3 className="text-lg font-bold text-gray-800">ë°ì´í„° ë¶ˆëŸ¬ì˜¤ê¸°</h3>
          <button onClick={onClose} className="p-1 hover:bg-gray-100 rounded-full">
            <X className="w-5 h-5 text-gray-500" />
          </button>
        </div>
        <p className="text-sm text-gray-500">
          ë°±ì—…ëœ í…ìŠ¤íŠ¸(JSON)ë¥¼ ì•„ë˜ ìƒìì— ë¶™ì—¬ë„£ê¸°(Ctrl+V) í•˜ì„¸ìš”.
        </p>
        <textarea 
          className="w-full h-40 p-3 border border-gray-200 rounded-xl text-xs font-mono text-gray-600 focus:outline-none focus:ring-2 focus:ring-indigo-500 resize-none"
          placeholder='[{"id": 123, "text": "í• ì¼...", ...}]'
          value={textData}
          onChange={(e) => setTextData(e.target.value)}
        />
        <div className="flex gap-2 mt-2">
          <button 
            onClick={onClose}
            className="flex-1 py-3 bg-gray-100 text-gray-600 rounded-xl font-bold hover:bg-gray-200 transition-colors"
          >
            ì·¨ì†Œ
          </button>
          <button 
            onClick={handleSave}
            className="flex-1 py-3 bg-indigo-600 text-white rounded-xl font-bold hover:bg-indigo-700 transition-colors shadow-md"
          >
            ë³µêµ¬í•˜ê¸°
          </button>
        </div>
      </div>
    </div>
  );
};

const FocusFlowApp = () => {
  const [tasks, setTasks] = useState(() => {
    const saved = localStorage.getItem('focusflow_tasks');
    const parsed = saved ? JSON.parse(saved) : [];
    return parsed.map(t => ({ ...t, subtasks: t.subtasks || [] }));
  });
  
  const [inputValue, setInputValue] = useState('');
  const [viewMode, setViewMode] = useState('matrix'); 
  const [timerActive, setTimerActive] = useState(false);
  const [timeLeft, setTimeLeft] = useState(25 * 60); 
  const [activeTab, setActiveTab] = useState('all'); 
  
  const [addingSubtaskTo, setAddingSubtaskTo] = useState(null);
  const [draggedTaskId, setDraggedTaskId] = useState(null);
  const [draggedType, setDraggedType] = useState(null);
  
  // Modal State
  const [isModalOpen, setIsModalOpen] = useState(false);

  useEffect(() => {
    localStorage.setItem('focusflow_tasks', JSON.stringify(tasks));
  }, [tasks]);

  useEffect(() => {
    let interval = null;
    if (timerActive && timeLeft > 0) {
      interval = setInterval(() => {
        setTimeLeft((prev) => prev - 1);
      }, 1000);
    } else if (timeLeft === 0) {
      setTimerActive(false);
    }
    return () => clearInterval(interval);
  }, [timerActive, timeLeft]);

  const formatTime = (seconds) => {
    const mins = Math.floor(seconds / 60);
    const secs = seconds % 60;
    return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
  };

  const adjustTime = (minutes) => {
    setTimeLeft(prev => {
      const newTime = prev + minutes * 60;
      return newTime > 0 ? newTime : 0;
    });
  };

  const addTask = (e) => {
    e.preventDefault();
    if (!inputValue.trim()) return;
    const newTask = {
      id: Date.now(),
      text: inputValue,
      urgent: false, 
      important: false,
      completed: false,
      subtasks: []
    };
    setTasks([newTask, ...tasks]);
    setInputValue('');
  };

  const updateTask = (id, newText) => {
    setTasks(prev => prev.map(t => t.id === id ? { ...t, text: newText } : t));
  };

  const addSubtask = (parentId, text) => {
    setTasks(prevTasks => prevTasks.map(t => {
      if (t.id === parentId) {
        return {
          ...t,
          subtasks: [...t.subtasks, { id: Date.now(), text: text, completed: false }]
        };
      }
      return t;
    }));
  };

  const updateSubtask = (parentId, subtaskId, newText) => {
    setTasks(prev => prev.map(t => {
      if (t.id === parentId) {
        return {
          ...t,
          subtasks: t.subtasks.map(st => st.id === subtaskId ? { ...st, text: newText } : st)
        };
      }
      return t;
    }));
  };

  const reorderSubtask = (parentId, draggedSubtaskId, targetSubtaskId, position) => {
    setTasks(prev => prev.map(t => {
      if (t.id === parentId) {
        const subtasks = [...t.subtasks];
        const draggedIndex = subtasks.findIndex(st => st.id === draggedSubtaskId);
        let targetIndex = subtasks.findIndex(st => st.id === targetSubtaskId);
        
        if (draggedIndex === -1 || targetIndex === -1) return t;

        const [draggedItem] = subtasks.splice(draggedIndex, 1);
        if (draggedIndex < targetIndex) {
          targetIndex -= 1;
        }
        if (position === 'bottom') {
          targetIndex += 1;
        }
        subtasks.splice(targetIndex, 0, draggedItem);
        
        return { ...t, subtasks };
      }
      return t;
    }));
  };

  const toggleTask = (id, field) => {
    setTasks(prev => prev.map(t => t.id === id ? { ...t, [field]: !t[field] } : t));
  };

  const toggleSubtask = (parentId, subtaskId) => {
    setTasks(prev => prev.map(t => {
      if (t.id === parentId) {
        return {
          ...t,
          subtasks: t.subtasks.map(st => st.id === subtaskId ? { ...st, completed: !st.completed } : st)
        };
      }
      return t;
    }));
  };

  const deleteTask = (id) => {
    setTasks(prev => prev.filter(t => t.id !== id));
  };

  const deleteSubtask = (parentId, subtaskId) => {
    setTasks(prev => prev.map(t => {
      if (t.id === parentId) {
        return {
          ...t,
          subtasks: t.subtasks.filter(st => st.id !== subtaskId)
        };
      }
      return t;
    }));
  };

  const onDragStart = (e, taskId, type) => {
    e.dataTransfer.setData("type", type);
    e.dataTransfer.setData("taskId", taskId);
    e.dataTransfer.effectAllowed = "move";
    setDraggedTaskId(taskId); 
    setDraggedType(type); 
  };

  const onDragEnd = () => {
    setDraggedTaskId(null); 
    setDraggedType(null); 
  };

  const onDropQuadrant = (e, targetUrgent, targetImportant) => {
    e.preventDefault();
    setDraggedTaskId(null);
    setDraggedType(null);
    const type = e.dataTransfer.getData("type");
    if (type !== "task") return; 

    const taskId = parseInt(e.dataTransfer.getData("taskId"));
    if (!taskId) return;

    setTasks(prevTasks => {
      const task = prevTasks.find(t => t.id === taskId);
      if (!task) return prevTasks;
      if (task.urgent === targetUrgent && task.important === targetImportant) return prevTasks;

      return prevTasks.map(t => 
        t.id === taskId ? { ...t, urgent: targetUrgent, important: targetImportant } : t
      );
    });
  };

  const onDropTask = (e, targetTask, position) => {
    e.preventDefault();
    e.stopPropagation();
    setDraggedTaskId(null);
    setDraggedType(null);
    const type = e.dataTransfer.getData("type");
    if (type !== "task") return;

    const draggedTaskId = parseInt(e.dataTransfer.getData("taskId"));
    if (!draggedTaskId || draggedTaskId === targetTask.id) return;

    setTasks(prevTasks => {
      const draggedTaskIndex = prevTasks.findIndex(t => t.id === draggedTaskId);
      let targetTaskIndex = prevTasks.findIndex(t => t.id === targetTask.id);
      
      if (draggedTaskIndex < 0 || targetTaskIndex < 0) return prevTasks;

      const newTasks = [...prevTasks];
      const [draggedItem] = newTasks.splice(draggedTaskIndex, 1);
      
      draggedItem.urgent = targetTask.urgent;
      draggedItem.important = targetTask.important;

      if (draggedTaskIndex < targetTaskIndex) {
        targetTaskIndex -= 1;
      }
      if (position === 'bottom') {
        targetTaskIndex += 1;
      }

      newTasks.splice(targetTaskIndex, 0, draggedItem);
      return newTasks;
    });
  };

  const onDragOver = (e) => {
    e.preventDefault();
  };

  // --- New Backup Logic (Clipboard + Modal) ---

  const copyBackupToClipboard = () => {
    const dataStr = JSON.stringify(tasks, null, 2);
    
    // Fallback for older browsers or iframe limitations
    const textArea = document.createElement("textarea");
    textArea.value = dataStr;
    document.body.appendChild(textArea);
    textArea.select();
    try {
      document.execCommand('copy');
      alert("ë°±ì—… ë°ì´í„°ê°€ í´ë¦½ë³´ë“œì— ë³µì‚¬ë˜ì—ˆìŠµë‹ˆë‹¤!\n\në©”ëª¨ì¥ ë“±ì— ë¶™ì—¬ë„£ê¸°(Ctrl+V)í•´ì„œ ë³´ê´€í•˜ì„¸ìš”.");
    } catch (err) {
      console.error('Copy failed', err);
      alert("ë³µì‚¬ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.");
    }
    document.body.removeChild(textArea);
  };

  const handleRestore = (restoredTasks) => {
    if (window.confirm(`ì´ ${restoredTasks.length}ê°œì˜ í•  ì¼ì„ ë³µêµ¬í•˜ì‹œê² ìŠµë‹ˆê¹Œ?\ní˜„ì¬ ëª©ë¡ì€ ì‚¬ë¼ì§‘ë‹ˆë‹¤.`)) {
      setTasks(restoredTasks);
      alert('ë³µêµ¬ ì™„ë£Œ!');
    }
  };

  const copyToNotion = () => {
    const q1 = tasks.filter(t => t.urgent && t.important && !t.completed);
    const q2 = tasks.filter(t => !t.urgent && t.important && !t.completed);
    const q3 = tasks.filter(t => t.urgent && !t.important && !t.completed);
    const q4 = tasks.filter(t => !t.urgent && !t.important && !t.completed);
    
    const formatTask = (t) => {
      let str = `- [${t.completed ? 'x' : ' '}] ${t.text}\n`;
      if (t.subtasks && t.subtasks.length > 0) {
        t.subtasks.forEach(st => {
          str += `    - [${st.completed ? 'x' : ' '}] ${st.text}\n`;
        });
      }
      return str;
    };

    let textToCopy = "# ì˜¤ëŠ˜ì˜ í•  ì¼\n\n";
    if (q1.length > 0) { textToCopy += "### ğŸš¨ ë°”ë¡œ ì§„í–‰ê±´\n"; q1.forEach(t => textToCopy += formatTask(t)); textToCopy += "\n"; }
    if (q2.length > 0) { textToCopy += "### ğŸ“… ì£¼ìš” ì—…ë¬´\n"; q2.forEach(t => textToCopy += formatTask(t)); textToCopy += "\n"; }
    if (q3.length > 0) { textToCopy += "### ğŸ¤ ë¶€ì°¨ì  ì—…ë¬´\n"; q3.forEach(t => textToCopy += formatTask(t)); textToCopy += "\n"; }
    if (q4.length > 0) { textToCopy += "### ğŸ“¥ ë³„ë¡œ ì•ˆ ì¤‘ìš”í•¨\n"; q4.forEach(t => textToCopy += formatTask(t)); textToCopy += "\n"; }

    const completed = tasks.filter(t => t.completed);
    if (completed.length > 0) { textToCopy += "### âœ… ì™„ë£Œëœ í•­ëª©\n"; completed.forEach(t => textToCopy += formatTask(t)); }

    const textArea = document.createElement("textarea");
    textArea.value = textToCopy;
    document.body.appendChild(textArea);
    textArea.select();
    document.execCommand('copy');
    document.body.removeChild(textArea);

    alert("í´ë¦½ë³´ë“œì— ë³µì‚¬ë˜ì—ˆìŠµë‹ˆë‹¤.");
  };

  const urgentImportant = tasks.filter(t => t.urgent && t.important && !t.completed);
  const notUrgentImportant = tasks.filter(t => !t.urgent && t.important && !t.completed);
  const urgentNotImportant = tasks.filter(t => t.urgent && !t.important && !t.completed);
  const notUrgentNotImportant = tasks.filter(t => !t.urgent && !t.important && !t.completed);

  return (
    <div className="min-h-screen bg-[#F5F5F7] font-sans text-gray-900 flex flex-col md:flex-row selection:bg-indigo-100 selection:text-indigo-900" onDragEnd={onDragEnd}>
      <DataModal 
        isOpen={isModalOpen} 
        onClose={() => setIsModalOpen(false)} 
        onSave={handleRestore} 
      />

      <aside className="w-full md:w-[280px] bg-white/80 backdrop-blur-xl border-r border-gray-200/60 flex flex-col z-20 md:sticky md:top-0 h-auto md:h-screen">
        <div className="p-8 pb-6">
          <h1 className="text-xl font-bold tracking-tighter text-gray-900 flex items-center gap-2">
            <div className="w-7 h-7 bg-black rounded-lg flex items-center justify-center text-white">
              <CheckCircle2 className="w-4 h-4" />
            </div>
            FocusFlow
          </h1>
        </div>

        <div className="px-6 mb-6">
          <div className="p-5 bg-white rounded-2xl border border-gray-100 shadow-[0_4px_20px_-12px_rgba(0,0,0,0.1)] flex flex-col items-center text-center group hover:border-indigo-100 transition-colors">
            <div className="text-[10px] font-bold tracking-widest text-gray-400 uppercase mb-3">Focus Timer</div>
            
            <div className="relative flex items-center justify-center mb-5 group/timer">
              {!timerActive && (
                <button 
                  onClick={() => adjustTime(-5)}
                  className="absolute left-0 opacity-0 group-hover/timer:opacity-100 p-2 text-gray-300 hover:text-gray-600 transition-opacity"
                  title="-5ë¶„"
                >
                  <Minus className="w-5 h-5" />
                </button>
              )}

              <div className={`text-4xl font-semibold tracking-tight font-mono tabular-nums cursor-default ${timerActive ? 'text-indigo-600' : 'text-gray-800'}`}>
                {formatTime(timeLeft)}
              </div>

              {!timerActive && (
                <button 
                  onClick={() => adjustTime(5)}
                  className="absolute right-0 opacity-0 group-hover/timer:opacity-100 p-2 text-gray-300 hover:text-gray-600 transition-opacity"
                  title="+5ë¶„"
                >
                  <Plus className="w-5 h-5" />
                </button>
              )}
            </div>

            <div className="flex gap-2 w-full">
              <button 
                onClick={() => setTimerActive(!timerActive)}
                className={`flex-1 h-10 rounded-xl flex items-center justify-center gap-1.5 text-sm font-semibold transition-all ${timerActive ? 'bg-amber-400 text-white shadow-amber-200' : 'bg-black text-white shadow-lg shadow-gray-200 hover:bg-gray-800'}`}
              >
                {timerActive ? <Pause className="w-3.5 h-3.5" /> : <Play className="w-3.5 h-3.5 ml-0.5" />}
              </button>
              <button 
                onClick={() => { setTimerActive(false); setTimeLeft(25 * 60); }}
                className="w-10 h-10 rounded-xl bg-gray-50 text-gray-400 hover:text-gray-600 hover:bg-gray-100 flex items-center justify-center transition-colors"
              >
                <RotateCcw className="w-4 h-4" />
              </button>
            </div>
          </div>
        </div>

        <div className="px-4 space-y-1 flex-1">
          <button 
            onClick={() => setViewMode('matrix')}
            className={`w-full text-left px-4 py-3 rounded-xl flex items-center gap-3 text-sm font-medium transition-all ${viewMode === 'matrix' ? 'bg-gray-100 text-gray-900' : 'text-gray-500 hover:bg-gray-50 hover:text-gray-700'}`}
          >
            <LayoutGrid className="w-4 h-4" /> ë§¤íŠ¸ë¦­ìŠ¤ ë·°
          </button>
          <button 
            onClick={() => setViewMode('list')}
            className={`w-full text-left px-4 py-3 rounded-xl flex items-center gap-3 text-sm font-medium transition-all ${viewMode === 'list' ? 'bg-gray-100 text-gray-900' : 'text-gray-500 hover:bg-gray-50 hover:text-gray-700'}`}
          >
            <ListIcon className="w-4 h-4" /> ë¦¬ìŠ¤íŠ¸ ë·°
          </button>
        </div>

        <div className="p-6 mt-auto space-y-2">
          <button 
            onClick={copyToNotion}
            className="group w-full py-3 bg-white border border-gray-200 text-gray-600 rounded-xl text-sm font-semibold flex items-center justify-center gap-2 hover:border-gray-300 hover:text-gray-900 hover:shadow-md transition-all active:scale-[0.98]"
          >
            <Copy className="w-4 h-4 text-gray-400 group-hover:text-gray-900 transition-colors" /> ë…¸ì…˜ ë³µì‚¬
          </button>
          
          <div className="flex gap-2">
            <button 
              onClick={copyBackupToClipboard}
              className="flex-1 py-3 bg-gray-100 text-gray-600 rounded-xl text-xs font-bold flex items-center justify-center gap-1 hover:bg-gray-200 hover:text-gray-900 transition-colors"
              title="ë°±ì—… ë°ì´í„° í´ë¦½ë³´ë“œ ë³µì‚¬"
            >
              <ClipboardCopy className="w-3.5 h-3.5" /> ì €ì¥
            </button>
            <button 
              onClick={() => setIsModalOpen(true)}
              className="flex-1 py-3 bg-gray-100 text-gray-600 rounded-xl text-xs font-bold flex items-center justify-center gap-1 hover:bg-gray-200 hover:text-gray-900 transition-colors"
              title="ë°±ì—… ë°ì´í„° ë¶™ì—¬ë„£ê¸°"
            >
              <ClipboardPaste className="w-3.5 h-3.5" /> ë¶ˆëŸ¬ì˜¤ê¸°
            </button>
          </div>
        </div>
      </aside>

      <main className="flex-1 flex flex-col h-screen overflow-hidden relative">
        <div className="pt-8 pb-6 px-8 z-10 shrink-0">
          <form onSubmit={addTask} className="max-w-2xl mx-auto relative group">
            <div className="absolute inset-y-0 left-4 flex items-center pointer-events-none">
              <Plus className="w-5 h-5 text-gray-400" />
            </div>
            <input 
              type="text" 
              value={inputValue}
              onChange={(e) => setInputValue(e.target.value)}
              placeholder="ìƒˆë¡œìš´ í•  ì¼ ì…ë ¥..."
              className="w-full bg-white pl-12 pr-4 py-4 rounded-2xl shadow-[0_8px_30px_rgb(0,0,0,0.04)] border-0 outline-none text-gray-800 placeholder-gray-400 text-lg font-medium transition-shadow focus:shadow-[0_8px_30px_rgb(0,0,0,0.08)]"
            />
            <div className="absolute right-4 top-1/2 -translate-y-1/2 text-[10px] font-bold text-gray-300 border border-gray-100 bg-gray-50 px-1.5 py-0.5 rounded">
              ENTER
            </div>
          </form>
        </div>

        <div className="flex-1 overflow-y-auto px-4 md:px-8 pb-8">
          {viewMode === 'matrix' ? (
            <div className="grid grid-cols-1 md:grid-cols-2 gap-4 h-full max-w-6xl mx-auto min-h-[600px]">
              <Quadrant 
                id="q1" title="ë°”ë¡œ ì§„í–‰ê±´" description="ì¦‰ì‹œ ì²˜ë¦¬" tasks={urgentImportant} headerColor="bg-rose-500 text-rose-500" icon={AlertCircle} targetUrgent={true} targetImportant={true}
                toggleTask={toggleTask} deleteTask={deleteTask} updateTask={updateTask} toggleSubtask={toggleSubtask} deleteSubtask={deleteSubtask} updateSubtask={updateSubtask} addSubtask={addSubtask} reorderSubtask={reorderSubtask} addingSubtaskTo={addingSubtaskTo} setAddingSubtaskTo={setAddingSubtaskTo} onDragStart={onDragStart} onDragOver={onDragOver} onDropTask={onDropTask} onDropQuadrant={onDropQuadrant} draggedTaskId={draggedTaskId} draggedType={draggedType}
              />
              <Quadrant 
                id="q2" title="ì£¼ìš” ì—…ë¬´" description="ê³„íš ìˆ˜ë¦½" tasks={notUrgentImportant} headerColor="bg-blue-500 text-blue-500" icon={Star} targetUrgent={false} targetImportant={true}
                toggleTask={toggleTask} deleteTask={deleteTask} updateTask={updateTask} toggleSubtask={toggleSubtask} deleteSubtask={deleteSubtask} updateSubtask={updateSubtask} addSubtask={addSubtask} reorderSubtask={reorderSubtask} addingSubtaskTo={addingSubtaskTo} setAddingSubtaskTo={setAddingSubtaskTo} onDragStart={onDragStart} onDragOver={onDragOver} onDropTask={onDropTask} onDropQuadrant={onDropQuadrant} draggedTaskId={draggedTaskId} draggedType={draggedType}
              />
              <Quadrant 
                id="q3" title="ë¶€ì°¨ì  ì—…ë¬´" description="ìœ„ì„ ê°€ëŠ¥" tasks={urgentNotImportant} headerColor="bg-amber-500 text-amber-500" icon={Clock} targetUrgent={true} targetImportant={false}
                toggleTask={toggleTask} deleteTask={deleteTask} updateTask={updateTask} toggleSubtask={toggleSubtask} deleteSubtask={deleteSubtask} updateSubtask={updateSubtask} addSubtask={addSubtask} reorderSubtask={reorderSubtask} addingSubtaskTo={addingSubtaskTo} setAddingSubtaskTo={setAddingSubtaskTo} onDragStart={onDragStart} onDragOver={onDragOver} onDropTask={onDropTask} onDropQuadrant={onDropQuadrant} draggedTaskId={draggedTaskId} draggedType={draggedType}
              />
              <Quadrant 
                id="q4" title="ë³„ë¡œ ì•ˆ ì¤‘ìš”í•¨" description="ë³´ê´€í•¨" tasks={notUrgentNotImportant} headerColor="bg-slate-500 text-slate-500" icon={ListIcon} targetUrgent={false} targetImportant={false}
                toggleTask={toggleTask} deleteTask={deleteTask} updateTask={updateTask} toggleSubtask={toggleSubtask} deleteSubtask={deleteSubtask} updateSubtask={updateSubtask} addSubtask={addSubtask} reorderSubtask={reorderSubtask} addingSubtaskTo={addingSubtaskTo} setAddingSubtaskTo={setAddingSubtaskTo} onDragStart={onDragStart} onDragOver={onDragOver} onDropTask={onDropTask} onDropQuadrant={onDropQuadrant} draggedTaskId={draggedTaskId} draggedType={draggedType}
              />
            </div>
          ) : (
            <div className="max-w-3xl mx-auto bg-white rounded-3xl shadow-sm border border-gray-100 overflow-hidden min-h-[500px]">
               <div className="flex border-b border-gray-50 overflow-x-auto px-2">
                  {['all', 'active', 'completed'].map(tab => (
                    <button key={tab} onClick={() => setActiveTab(tab)} className={`px-6 py-5 text-sm font-bold transition-all whitespace-nowrap relative ${activeTab === tab ? 'text-gray-900' : 'text-gray-400 hover:text-gray-600'}`}>
                      {tab === 'all' ? 'ì „ì²´' : tab === 'active' ? 'ì§„í–‰ì¤‘' : 'ì™„ë£Œë¨'}
                      {activeTab === tab && (<div className="absolute bottom-0 left-1/2 -translate-x-1/2 w-1 h-1 bg-black rounded-full mb-2" />)}
                    </button>
                  ))}
               </div>
               <div className="p-6 max-h-[70vh] overflow-y-auto custom-scrollbar">
                 {tasks
                    .filter(t => {
                      if (activeTab === 'active') return !t.completed;
                      if (activeTab === 'completed') return t.completed;
                      return true;
                    })
                    .map(t => (
                      <TaskItem 
                        key={t.id} task={t} toggleTask={toggleTask} deleteTask={deleteTask} updateTask={updateTask} toggleSubtask={toggleSubtask} deleteSubtask={deleteSubtask} updateSubtask={updateSubtask} addSubtask={addSubtask} reorderSubtask={reorderSubtask} addingSubtaskTo={addingSubtaskTo} setAddingSubtaskTo={setAddingSubtaskTo} onDragStart={onDragStart} onDragOver={onDragOver} onDropTask={onDropTask}
                        isDraggingSource={draggedTaskId === t.id}
                        draggedType={draggedType}
                      />
                    ))
                 }
                 {tasks.length === 0 && (
                   <div className="py-20 text-center">
                     <div className="inline-flex items-center justify-center w-12 h-12 rounded-full bg-gray-50 mb-3"><ListIcon className="w-5 h-5 text-gray-300" /></div>
                     <p className="text-gray-400 text-sm">í•  ì¼ì´ ì—†ìŠµë‹ˆë‹¤.</p>
                   </div>
                 )}
               </div>
            </div>
          )}
        </div>
      </main>
    </div>
  );
};

export default FocusFlowApp;
