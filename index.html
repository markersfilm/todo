<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FocusFlow - Ìï† Ïùº Í¥ÄÎ¶¨</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script type="importmap">
    {
        "imports": {
            "react": "https://esm.sh/react@18.2.0",
            "react-dom/client": "https://esm.sh/react-dom@18.2.0/client",
            "lucide-react": "https://esm.sh/lucide-react@0.292.0"
        }
    }
    </script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <style>
        .custom-scrollbar::-webkit-scrollbar { width: 6px; height: 6px; }
        .custom-scrollbar::-webkit-scrollbar-track { background: transparent; }
        .custom-scrollbar::-webkit-scrollbar-thumb { background-color: #cbd5e1; border-radius: 20px; }
        .custom-scrollbar::-webkit-scrollbar-thumb:hover { background-color: #94a3b8; }
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif; }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel" data-type="module">
        import React, { useState, useEffect, useRef, memo } from 'react';
        import { createRoot } from 'react-dom/client';
        import { 
            CheckSquare, Square, Trash2, Copy, Plus, Clock, Play, Pause, RotateCcw, 
            LayoutGrid, List as ListIcon, AlertCircle, Star, CheckCircle2, GripVertical, 
            CornerDownRight, X, Pencil, Minus
        } from 'lucide-react';

        // --- Components ---

        const TaskItem = memo(({ 
            task, toggleTask, deleteTask, updateTask, toggleSubtask, deleteSubtask, updateSubtask, 
            addSubtask, addingSubtaskTo, setAddingSubtaskTo, reorderSubtask, onDragStart, 
            onDragOver, onDropTask, isDraggingSource, draggedType 
        }) => {
            const [isEditing, setIsEditing] = useState(false);
            const [editText, setEditText] = useState(task.text);
            const [dropPosition, setDropPosition] = useState(null); 
            const inputRef = useRef(null);
            const subtaskInputRef = useRef(null);
            const itemRef = useRef(null);

            const isAddingSubtask = addingSubtaskTo === task.id;

            useEffect(() => {
                if (isEditing && inputRef.current) inputRef.current.focus();
            }, [isEditing]);

            useEffect(() => {
                if (isAddingSubtask && subtaskInputRef.current) subtaskInputRef.current.focus();
            }, [isAddingSubtask]);

            const startEditing = () => { setIsEditing(true); setEditText(task.text); };

            const saveEdit = () => {
                if (editText.trim()) updateTask(task.id, editText);
                else setEditText(task.text); 
                setIsEditing(false);
            };

            const handleEditKeyDown = (e) => {
                if (e.nativeEvent.isComposing) return;
                if (e.key === 'Enter') saveEdit();
                if (e.key === 'Escape') { setEditText(task.text); setIsEditing(false); }
            };

            const handleSubtaskSubmit = (e) => {
                if (e.nativeEvent.isComposing) return;
                if (e.key === 'Enter') {
                    e.preventDefault();
                    const text = e.target.value;
                    if (text.trim()) {
                        addSubtask(task.id, text);
                        e.target.value = ''; 
                    }
                }
            };

            const handleDragOver = (e) => {
                e.preventDefault(); e.stopPropagation();
                if (!itemRef.current || isDraggingSource || draggedType !== 'task') { setDropPosition(null); return; }
                const rect = itemRef.current.getBoundingClientRect();
                if (e.clientY < rect.top + rect.height / 2) setDropPosition('top');
                else setDropPosition('bottom');
            };

            const handleDragLeave = () => setDropPosition(null);

            const handleDrop = (e) => {
                e.preventDefault(); e.stopPropagation(); setDropPosition(null);
                if (draggedType === 'task') onDropTask(e, task, dropPosition);
            };

            const onSubtaskDragStart = (e, subtaskId) => {
                e.stopPropagation(); 
                e.dataTransfer.setData("type", "subtask");
                e.dataTransfer.setData("parentId", task.id);
                e.dataTransfer.setData("subtaskId", subtaskId);
                e.dataTransfer.effectAllowed = "move";
                onDragStart(e, task.id, 'subtask'); 
            };

            const commonTextStyle = "text-[15px] font-medium leading-snug px-1 py-0.5 rounded border";

            return (
                <div 
                    ref={itemRef} draggable={!isEditing}
                    onDragStart={(e) => onDragStart(e, task.id, 'task')} 
                    onDragOver={handleDragOver} onDragLeave={handleDragLeave} onDrop={handleDrop}
                    className={`group relative flex flex-col p-4 rounded-xl mb-3 transition-all duration-200 border border-transparent ${
                        isDraggingSource ? 'opacity-40 bg-gray-100 border-dashed border-gray-300 scale-[0.98]' : 
                        task.completed ? 'bg-gray-50/50 opacity-60' : 'bg-white hover:shadow-md shadow-sm hover:border-gray-100'
                    }`}
                >
                    {dropPosition === 'top' && <div className="absolute -top-2 left-0 right-0 h-1 bg-indigo-500 rounded-full pointer-events-none z-50 shadow-sm ring-2 ring-white transition-all duration-200"></div>}
                    {dropPosition === 'bottom' && <div className="absolute -bottom-2 left-0 right-0 h-1 bg-indigo-500 rounded-full pointer-events-none z-50 shadow-sm ring-2 ring-white transition-all duration-200"></div>}

                    <div className="flex items-start gap-3.5 pointer-events-none"> 
                        <div className="mt-1 text-gray-200 group-hover:text-gray-400 transition-colors cursor-grab active:cursor-grabbing shrink-0 pointer-events-auto">
                            <GripVertical className="w-4 h-4" />
                        </div>
                        <button onClick={() => toggleTask(task.id, 'completed')} className="mt-0.5 shrink-0 transition-colors pointer-events-auto">
                            {task.completed ? <CheckCircle2 className="w-5 h-5 text-gray-400" /> : <div className="w-5 h-5 rounded-full border-2 border-gray-300 hover:border-indigo-500 transition-colors" />}
                        </button>
                        <div className="flex-1 min-w-0 pointer-events-auto">
                            {isEditing ? (
                                <input ref={inputRef} type="text" value={editText} onChange={(e) => setEditText(e.target.value)} onBlur={saveEdit} onKeyDown={handleEditKeyDown} className={`w-full bg-gray-50 focus:outline-none focus:ring-2 focus:ring-indigo-100 text-gray-800 border-transparent ${commonTextStyle}`} />
                            ) : (
                                <span onDoubleClick={startEditing} className={`block cursor-default border-transparent ${commonTextStyle} ${task.completed ? 'line-through text-gray-400' : 'text-gray-800'}`}>{task.text}</span>
                            )}
                        </div>
                        <div className="flex items-center gap-1 opacity-0 group-hover:opacity-100 transition-opacity shrink-0 pointer-events-auto">
                            <button onClick={() => setAddingSubtaskTo(task.id)} title="ÌïòÏúÑ Ìï≠Î™© Ï∂îÍ∞Ä" className="p-1.5 text-gray-300 hover:text-indigo-500 hover:bg-indigo-50 rounded-md transition-colors"><CornerDownRight className="w-3.5 h-3.5" /></button>
                            <button onClick={startEditing} title="ÏàòÏ†ï (ÎçîÎ∏îÌÅ¥Î¶≠)" className="p-1.5 text-gray-300 hover:text-blue-500 hover:bg-blue-50 rounded-md transition-colors"><Pencil className="w-3.5 h-3.5" /></button>
                            <button onClick={() => deleteTask(task.id)} title="ÏÇ≠Ï†ú" className="p-1.5 text-gray-300 hover:text-red-500 hover:bg-red-50 rounded-md transition-colors"><Trash2 className="w-3.5 h-3.5" /></button>
                        </div>
                    </div>

                    {(task.subtasks?.length > 0 || isAddingSubtask) && (
                        <div className="mt-2 space-y-1 ml-[1.875rem]"> 
                            {task.subtasks.map(st => (
                                <SubtaskItem key={st.id} subtask={st} parentId={task.id} toggleSubtask={toggleSubtask} deleteSubtask={deleteSubtask} updateSubtask={updateSubtask} onDragStart={onSubtaskDragStart} onDrop={(e, pos) => reorderSubtask(task.id, parseInt(e.dataTransfer.getData("subtaskId")), st.id, pos)} draggedType={draggedType} />
                            ))}
                            {isAddingSubtask && (
                                <div className="flex items-center gap-1 pl-1 py-1 animate-in fade-in slide-in-from-top-1 duration-200 bg-gray-50/50 rounded-lg">
                                    <div className="w-5 flex justify-center"><CornerDownRight className="w-3.5 h-3.5 text-indigo-300" /></div>
                                    <input ref={subtaskInputRef} type="text" onKeyDown={handleSubtaskSubmit} onBlur={() => setAddingSubtaskTo(null)} placeholder="ÌïòÏúÑ Ìï≠Î™© ÏûÖÎ†•..." className="flex-1 bg-transparent text-sm p-1 focus:outline-none text-gray-600 placeholder-gray-300 ime-mode-active" />
                                </div>
                            )}
                        </div>
                    )}
                </div>
            );
        });

        const SubtaskItem = memo(({ subtask, parentId, toggleSubtask, deleteSubtask, updateSubtask, onDragStart, onDrop, draggedType }) => {
            const [isEditing, setIsEditing] = useState(false);
            const [text, setText] = useState(subtask.text);
            const [dropPosition, setDropPosition] = useState(null);
            const inputRef = useRef(null);
            const itemRef = useRef(null);

            useEffect(() => {
                if (isEditing && inputRef.current) { inputRef.current.focus(); inputRef.current.setSelectionRange(text.length, text.length); }
            }, [isEditing]);

            const save = () => { if (text.trim()) updateSubtask(parentId, subtask.id, text); else setText(subtask.text); setIsEditing(false); };
            const handleKeyDown = (e) => { if (e.nativeEvent.isComposing) return; if (e.key === 'Enter') save(); if (e.key === 'Escape') { setText(subtask.text); setIsEditing(false); } };
            
            const handleDragOver = (e) => {
                e.preventDefault(); e.stopPropagation();
                if (!itemRef.current || draggedType !== 'subtask') { setDropPosition(null); return; }
                const rect = itemRef.current.getBoundingClientRect();
                if (e.clientY < rect.top + rect.height / 2) setDropPosition('top'); else setDropPosition('bottom');
            };

            const handleDrop = (e) => { e.preventDefault(); e.stopPropagation(); setDropPosition(null); if (draggedType === 'subtask') onDrop(e, dropPosition); };

            return (
                <div ref={itemRef} draggable={!isEditing} onDragStart={(e) => onDragStart(e, subtask.id)} onDragOver={handleDragOver} onDragLeave={() => setDropPosition(null)} onDrop={handleDrop} className={`flex items-start gap-1 group/sub px-2 py-1.5 rounded-lg cursor-grab active:cursor-grabbing relative transition-colors w-full ${isEditing ? 'bg-white ring-2 ring-indigo-100 shadow-sm z-10' : 'hover:bg-gray-100'}`}>
                    {dropPosition === 'top' && <div className="absolute -top-0.5 left-0 right-0 h-0.5 bg-indigo-400 rounded-full pointer-events-none z-50"></div>}
                    {dropPosition === 'bottom' && <div className="absolute -bottom-0.5 left-0 right-0 h-0.5 bg-indigo-400 rounded-full pointer-events-none z-50"></div>}
                    <div className="mt-1 w-3 h-4 flex-shrink-0 flex items-center justify-center"><GripVertical className="w-3 h-3 text-gray-300 opacity-0 group-hover/sub:opacity-100 cursor-grab" /></div>
                    <div className="mt-1 w-4 flex justify-center flex-shrink-0"><CornerDownRight className="w-3.5 h-3.5 text-gray-400" /></div>
                    <button onClick={() => toggleSubtask(parentId, subtask.id)} className="mt-0.5 flex-shrink-0">{subtask.completed ? <CheckSquare className="w-4 h-4 text-gray-400" /> : <Square className="w-4 h-4 text-gray-300 hover:text-indigo-400" />}</button>
                    <div className="flex-1 min-w-0 ml-1">
                        {isEditing ? (
                            <textarea ref={inputRef} value={text} onChange={e => setText(e.target.value)} onBlur={save} onKeyDown={handleKeyDown} rows={1} style={{ height: 'auto', minHeight: '24px' }} className="resize-none overflow-hidden text-sm focus:outline-none bg-transparent w-full block break-words whitespace-pre-wrap leading-relaxed" onInput={(e) => { e.target.style.height = 'auto'; e.target.style.height = e.target.scrollHeight + 'px'; }} />
                        ) : (
                            <span onDoubleClick={() => setIsEditing(true)} className={`cursor-default border-transparent text-sm block break-words whitespace-pre-wrap leading-relaxed ${subtask.completed ? 'line-through text-gray-400' : 'text-gray-600'}`}>{subtask.text}</span>
                        )}
                    </div>
                    <button onClick={() => deleteSubtask(parentId, subtask.id)} className="opacity-0 group-hover/sub:opacity-100 text-gray-300 hover:text-red-400 ml-2 p-0.5 flex-shrink-0"><X className="w-3.5 h-3.5" /></button>
                </div>
            );
        });

        const Quadrant = memo(({ 
            id, title, description, tasks, headerColor, icon: Icon, targetUrgent, targetImportant,
            toggleTask, deleteTask, updateTask, toggleSubtask, deleteSubtask, updateSubtask, addSubtask, reorderSubtask,
            addingSubtaskTo, setAddingSubtaskTo, onDragStart, onDragOver, onDropTask, onDropQuadrant, draggedTaskId, draggedType 
        }) => {
            return (
                <div onDragOver={onDragOver} onDrop={(e) => onDropQuadrant(e, targetUrgent, targetImportant)} className="flex flex-col h-full bg-white rounded-3xl shadow-[0_2px_12px_-4px_rgba(0,0,0,0.05)] border border-gray-100 overflow-hidden hover:shadow-md transition-shadow duration-300">
                    <div className="px-6 pt-6 pb-4">
                        <div className="flex items-center justify-between mb-1">
                            <div className="flex items-center gap-2.5">
                                <div className={`p-2 rounded-xl ${headerColor} bg-opacity-10`}><Icon className={`w-4 h-4 ${headerColor.replace('bg-', 'text-')}`} /></div>
                                <h3 className="font-bold text-gray-800 text-lg tracking-tight">{title}</h3>
                            </div>
                            <span className="text-xs font-bold px-2.5 py-1 rounded-full bg-gray-50 text-gray-400">{tasks.length}</span>
                        </div>
                    </div>
                    <div className="flex-1 overflow-y-auto custom-scrollbar px-4 pb-4 min-h-[100px] bg-gray-50/30">
                        {tasks.length === 0 ? (
                            <div className="h-full flex flex-col items-center justify-center"><span className="text-gray-300 text-sm font-medium">ÎπÑÏñ¥ÏûàÏùå</span></div>
                        ) : (
                            <div className="pt-2">
                                {tasks.map(t => (
                                    <TaskItem key={t.id} task={t} toggleTask={toggleTask} deleteTask={deleteTask} updateTask={updateTask} toggleSubtask={toggleSubtask} deleteSubtask={deleteSubtask} updateSubtask={updateSubtask} addSubtask={addSubtask} reorderSubtask={reorderSubtask} addingSubtaskTo={addingSubtaskTo} setAddingSubtaskTo={setAddingSubtaskTo} onDragStart={onDragStart} onDragOver={onDragOver} onDropTask={onDropTask} isDraggingSource={draggedTaskId === t.id} draggedType={draggedType} />
                                ))}
                            </div>
                        )}
                    </div>
                </div>
            );
        });

        const FocusFlowApp = () => {
            // ** Ïó¨Í∏∞(localStorage)Í∞Ä ÏûêÎèô Ï†ÄÏû• ÌïµÏã¨ÏûÖÎãàÎã§ **
            const [tasks, setTasks] = useState(() => {
                const saved = localStorage.getItem('focusflow_tasks');
                const parsed = saved ? JSON.parse(saved) : [];
                return parsed.map(t => ({ ...t, subtasks: t.subtasks || [] }));
            });
            
            const [inputValue, setInputValue] = useState('');
            const [viewMode, setViewMode] = useState('matrix'); 
            const [timerActive, setTimerActive] = useState(false);
            const [timeLeft, setTimeLeft] = useState(25 * 60); 
            const [activeTab, setActiveTab] = useState('all'); 
            const [addingSubtaskTo, setAddingSubtaskTo] = useState(null);
            const [draggedTaskId, setDraggedTaskId] = useState(null);
            const [draggedType, setDraggedType] = useState(null);

            // ** tasks ÏÉÅÌÉúÍ∞Ä Î≥ÄÌï† ÎïåÎßàÎã§ Î∏åÎùºÏö∞Ï†Ä Ï†ÄÏû•ÏÜåÏóê ÏûêÎèô Ï†ÄÏû• **
            useEffect(() => { localStorage.setItem('focusflow_tasks', JSON.stringify(tasks)); }, [tasks]);

            useEffect(() => {
                let interval = null;
                if (timerActive && timeLeft > 0) interval = setInterval(() => { setTimeLeft((prev) => prev - 1); }, 1000);
                else if (timeLeft === 0) setTimerActive(false);
                return () => clearInterval(interval);
            }, [timerActive, timeLeft]);

            const formatTime = (seconds) => `${Math.floor(seconds / 60).toString().padStart(2, '0')}:${(seconds % 60).toString().padStart(2, '0')}`;
            const adjustTime = (minutes) => { setTimeLeft(prev => { const newTime = prev + minutes * 60; return newTime > 0 ? newTime : 0; }); };

            const addTask = (e) => {
                e.preventDefault(); if (!inputValue.trim()) return;
                const newTask = { id: Date.now(), text: inputValue, urgent: false, important: false, completed: false, subtasks: [] };
                setTasks([newTask, ...tasks]); setInputValue('');
            };

            const updateTask = (id, newText) => setTasks(prev => prev.map(t => t.id === id ? { ...t, text: newText } : t));
            const addSubtask = (parentId, text) => setTasks(prev => prev.map(t => t.id === parentId ? { ...t, subtasks: [...t.subtasks, { id: Date.now(), text: text, completed: false }] } : t));
            const updateSubtask = (parentId, subtaskId, newText) => setTasks(prev => prev.map(t => t.id === parentId ? { ...t, subtasks: t.subtasks.map(st => st.id === subtaskId ? { ...st, text: newText } : st) } : t));
            
            const reorderSubtask = (parentId, draggedSubtaskId, targetSubtaskId, position) => {
                setTasks(prev => prev.map(t => {
                    if (t.id === parentId) {
                        const subtasks = [...t.subtasks];
                        const draggedIndex = subtasks.findIndex(st => st.id === draggedSubtaskId);
                        let targetIndex = subtasks.findIndex(st => st.id === targetSubtaskId);
                        if (draggedIndex === -1 || targetIndex === -1) return t;
                        const [draggedItem] = subtasks.splice(draggedIndex, 1);
                        if (draggedIndex < targetIndex) targetIndex -= 1;
                        if (position === 'bottom') targetIndex += 1;
                        subtasks.splice(targetIndex, 0, draggedItem);
                        return { ...t, subtasks };
                    }
                    return t;
                }));
            };

            const toggleTask = (id, field) => setTasks(prev => prev.map(t => t.id === id ? { ...t, [field]: !t[field] } : t));
            const toggleSubtask = (parentId, subtaskId) => setTasks(prev => prev.map(t => t.id === parentId ? { ...t, subtasks: t.subtasks.map(st => st.id === subtaskId ? { ...st, completed: !st.completed } : st) } : t));
            const deleteTask = (id) => setTasks(prev => prev.filter(t => t.id !== id));
            const deleteSubtask = (parentId, subtaskId) => setTasks(prev => prev.map(t => t.id === parentId ? { ...t, subtasks: t.subtasks.filter(st => st.id !== subtaskId) } : t));

            const onDragStart = (e, taskId, type) => {
                e.dataTransfer.setData("type", type); e.dataTransfer.setData("taskId", taskId); e.dataTransfer.effectAllowed = "move";
                setDraggedTaskId(taskId); setDraggedType(type); 
            };

            const onDragEnd = () => { setDraggedTaskId(null); setDraggedType(null); };

            const onDropQuadrant = (e, targetUrgent, targetImportant) => {
                e.preventDefault(); setDraggedTaskId(null); setDraggedType(null);
                const type = e.dataTransfer.getData("type"); if (type !== "task") return; 
                const taskId = parseInt(e.dataTransfer.getData("taskId")); if (!taskId) return;
                setTasks(prevTasks => prevTasks.map(t => t.id === taskId ? { ...t, urgent: targetUrgent, important: targetImportant } : t));
            };

            const onDropTask = (e, targetTask, position) => {
                e.preventDefault(); e.stopPropagation(); setDraggedTaskId(null); setDraggedType(null);
                const type = e.dataTransfer.getData("type"); if (type !== "task") return;
                const draggedTaskId = parseInt(e.dataTransfer.getData("taskId")); if (!draggedTaskId || draggedTaskId === targetTask.id) return;
                setTasks(prevTasks => {
                    const draggedTaskIndex = prevTasks.findIndex(t => t.id === draggedTaskId);
                    let targetTaskIndex = prevTasks.findIndex(t => t.id === targetTask.id);
                    if (draggedTaskIndex < 0 || targetTaskIndex < 0) return prevTasks;
                    const newTasks = [...prevTasks];
                    const [draggedItem] = newTasks.splice(draggedTaskIndex, 1);
                    draggedItem.urgent = targetTask.urgent; draggedItem.important = targetTask.important;
                    if (draggedTaskIndex < targetTaskIndex) targetTaskIndex -= 1;
                    if (position === 'bottom') targetTaskIndex += 1;
                    newTasks.splice(targetTaskIndex, 0, draggedItem);
                    return newTasks;
                });
            };

            const onDragOver = (e) => e.preventDefault();

            const copyToNotion = () => {
                const q1 = tasks.filter(t => t.urgent && t.important && !t.completed);
                const q2 = tasks.filter(t => !t.urgent && t.important && !t.completed);
                const q3 = tasks.filter(t => t.urgent && !t.important && !t.completed);
                const q4 = tasks.filter(t => !t.urgent && !t.important && !t.completed);
                
                const formatTask = (t) => {
                    let str = `- [${t.completed ? 'x' : ' '}] ${t.text}\n`;
                    if (t.subtasks?.length) t.subtasks.forEach(st => { str += `    - [${st.completed ? 'x' : ' '}] ${st.text}\n`; });
                    return str;
                };

                let textToCopy = "# Ïò§ÎäòÏùò Ìï† Ïùº\n\n";
                if (q1.length) { textToCopy += "### üö® Î∞îÎ°ú ÏßÑÌñâÍ±¥\n"; q1.forEach(t => textToCopy += formatTask(t)); textToCopy += "\n"; }
                if (q2.length) { textToCopy += "### üìÖ Ï£ºÏöî ÏóÖÎ¨¥\n"; q2.forEach(t => textToCopy += formatTask(t)); textToCopy += "\n"; }
                if (q3.length) { textToCopy += "### ü§ù Î∂ÄÏ∞®Ï†Å ÏóÖÎ¨¥\n"; q3.forEach(t => textToCopy += formatTask(t)); textToCopy += "\n"; }
                if (q4.length) { textToCopy += "### üì• Î≥ÑÎ°ú Ïïà Ï§ëÏöîÌï®\n"; q4.forEach(t => textToCopy += formatTask(t)); textToCopy += "\n"; }
                const completed = tasks.filter(t => t.completed);
                if (completed.length) { textToCopy += "### ‚úÖ ÏôÑÎ£åÎêú Ìï≠Î™©\n"; completed.forEach(t => textToCopy += formatTask(t)); }

                navigator.clipboard.writeText(textToCopy).then(() => alert("ÎÖ∏ÏÖòÏö© ÌÖçÏä§Ìä∏ Î≥µÏÇ¨ ÏôÑÎ£å!")).catch(() => alert("Î≥µÏÇ¨ Ïã§Ìå®"));
            };

            const urgentImportant = tasks.filter(t => t.urgent && t.important && !t.completed);
            const notUrgentImportant = tasks.filter(t => !t.urgent && t.important && !t.completed);
            const urgentNotImportant = tasks.filter(t => t.urgent && !t.important && !t.completed);
            const notUrgentNotImportant = tasks.filter(t => !t.urgent && !t.important && !t.completed);

            return (
                <div className="min-h-screen bg-[#F5F5F7] font-sans text-gray-900 flex flex-col md:flex-row selection:bg-indigo-100 selection:text-indigo-900" onDragEnd={onDragEnd}>
                    <aside className="w-full md:w-[280px] bg-white/80 backdrop-blur-xl border-r border-gray-200/60 flex flex-col z-20 md:sticky md:top-0 h-auto md:h-screen">
                        <div className="p-8 pb-6"><h1 className="text-xl font-bold tracking-tighter text-gray-900 flex items-center gap-2"><div className="w-7 h-7 bg-black rounded-lg flex items-center justify-center text-white"><CheckCircle2 className="w-4 h-4" /></div>FocusFlow</h1></div>
                        <div className="px-6 mb-6">
                            <div className="p-5 bg-white rounded-2xl border border-gray-100 shadow-[0_4px_20px_-12px_rgba(0,0,0,0.1)] flex flex-col items-center text-center group hover:border-indigo-100 transition-colors">
                                <div className="text-[10px] font-bold tracking-widest text-gray-400 uppercase mb-3">Focus Timer</div>
                                <div className="relative flex items-center justify-center mb-5 group/timer">
                                    {!timerActive && <button onClick={() => adjustTime(-5)} className="absolute left-0 opacity-0 group-hover/timer:opacity-100 p-2 text-gray-300 hover:text-gray-600 transition-opacity"><Minus className="w-5 h-5" /></button>}
                                    <div className={`text-4xl font-semibold tracking-tight font-mono tabular-nums cursor-default ${timerActive ? 'text-indigo-600' : 'text-gray-800'}`}>{formatTime(timeLeft)}</div>
                                    {!timerActive && <button onClick={() => adjustTime(5)} className="absolute right-0 opacity-0 group-hover/timer:opacity-100 p-2 text-gray-300 hover:text-gray-600 transition-opacity"><Plus className="w-5 h-5" /></button>}
                                </div>
                                <div className="flex gap-2 w-full">
                                    <button onClick={() => setTimerActive(!timerActive)} className={`flex-1 h-10 rounded-xl flex items-center justify-center gap-1.5 text-sm font-semibold transition-all ${timerActive ? 'bg-amber-400 text-white shadow-amber-200' : 'bg-black text-white shadow-lg shadow-gray-200 hover:bg-gray-800'}`}>{timerActive ? <Pause className="w-3.5 h-3.5" /> : <Play className="w-3.5 h-3.5 ml-0.5" />}</button>
                                    <button onClick={() => { setTimerActive(false); setTimeLeft(25 * 60); }} className="w-10 h-10 rounded-xl bg-gray-50 text-gray-400 hover:text-gray-600 hover:bg-gray-100 flex items-center justify-center transition-colors"><RotateCcw className="w-4 h-4" /></button>
                                </div>
                            </div>
                        </div>
                        <div className="px-4 space-y-1 flex-1">
                            <button onClick={() => setViewMode('matrix')} className={`w-full text-left px-4 py-3 rounded-xl flex items-center gap-3 text-sm font-medium transition-all ${viewMode === 'matrix' ? 'bg-gray-100 text-gray-900' : 'text-gray-500 hover:bg-gray-50 hover:text-gray-700'}`}><LayoutGrid className="w-4 h-4" /> Îß§Ìä∏Î¶≠Ïä§ Î∑∞</button>
                            <button onClick={() => setViewMode('list')} className={`w-full text-left px-4 py-3 rounded-xl flex items-center gap-3 text-sm font-medium transition-all ${viewMode === 'list' ? 'bg-gray-100 text-gray-900' : 'text-gray-500 hover:bg-gray-50 hover:text-gray-700'}`}><ListIcon className="w-4 h-4" /> Î¶¨Ïä§Ìä∏ Î∑∞</button>
                        </div>
                        <div className="p-6 mt-auto space-y-2">
                            <button onClick={copyToNotion} className="group w-full py-3 bg-white border border-gray-200 text-gray-600 rounded-xl text-sm font-semibold flex items-center justify-center gap-2 hover:border-gray-300 hover:text-gray-900 hover:shadow-md transition-all active:scale-[0.98]"><Copy className="w-4 h-4 text-gray-400 group-hover:text-gray-900 transition-colors" /> ÎÖ∏ÏÖò Î≥µÏÇ¨</button>
                        </div>
                    </aside>

                    <main className="flex-1 flex flex-col h-screen overflow-hidden relative">
                        <div className="pt-8 pb-6 px-8 z-10 shrink-0">
                            <form onSubmit={addTask} className="max-w-2xl mx-auto relative group">
                                <div className="absolute inset-y-0 left-4 flex items-center pointer-events-none"><Plus className="w-5 h-5 text-gray-400" /></div>
                                <input type="text" value={inputValue} onChange={(e) => setInputValue(e.target.value)} placeholder="ÏÉàÎ°úÏö¥ Ìï† Ïùº ÏûÖÎ†•..." className="w-full bg-white pl-12 pr-4 py-4 rounded-2xl shadow-[0_8px_30px_rgb(0,0,0,0.04)] border-0 outline-none text-gray-800 placeholder-gray-400 text-lg font-medium transition-shadow focus:shadow-[0_8px_30px_rgb(0,0,0,0.08)]" />
                                <div className="absolute right-4 top-1/2 -translate-y-1/2 text-[10px] font-bold text-gray-300 border border-gray-100 bg-gray-50 px-1.5 py-0.5 rounded">ENTER</div>
                            </form>
                        </div>

                        <div className="flex-1 overflow-y-auto px-4 md:px-8 pb-8">
                            {viewMode === 'matrix' ? (
                                <div className="grid grid-cols-1 md:grid-cols-2 gap-4 h-full max-w-6xl mx-auto min-h-[600px]">
                                    <Quadrant id="q1" title="Î∞îÎ°ú ÏßÑÌñâÍ±¥" description="Ï¶âÏãú Ï≤òÎ¶¨" tasks={urgentImportant} headerColor="bg-rose-500 text-rose-500" icon={AlertCircle} targetUrgent={true} targetImportant={true} toggleTask={toggleTask} deleteTask={deleteTask} updateTask={updateTask} toggleSubtask={toggleSubtask} deleteSubtask={deleteSubtask} updateSubtask={updateSubtask} addSubtask={addSubtask} reorderSubtask={reorderSubtask} addingSubtaskTo={addingSubtaskTo} setAddingSubtaskTo={setAddingSubtaskTo} onDragStart={onDragStart} onDragOver={onDragOver} onDropTask={onDropTask} onDropQuadrant={onDropQuadrant} draggedTaskId={draggedTaskId} draggedType={draggedType} />
                                    <Quadrant id="q2" title="Ï£ºÏöî ÏóÖÎ¨¥" description="Í≥ÑÌöç ÏàòÎ¶Ω" tasks={notUrgentImportant} headerColor="bg-blue-500 text-blue-500" icon={Star} targetUrgent={false} targetImportant={true} toggleTask={toggleTask} deleteTask={deleteTask} updateTask={updateTask} toggleSubtask={toggleSubtask} deleteSubtask={deleteSubtask} updateSubtask={updateSubtask} addSubtask={addSubtask} reorderSubtask={reorderSubtask} addingSubtaskTo={addingSubtaskTo} setAddingSubtaskTo={setAddingSubtaskTo} onDragStart={onDragStart} onDragOver={onDragOver} onDropTask={onDropTask} onDropQuadrant={onDropQuadrant} draggedTaskId={draggedTaskId} draggedType={draggedType} />
                                    <Quadrant id="q3" title="Î∂ÄÏ∞®Ï†Å ÏóÖÎ¨¥" description="ÏúÑÏûÑ Í∞ÄÎä•" tasks={urgentNotImportant} headerColor="bg-amber-500 text-amber-500" icon={Clock} targetUrgent={true} targetImportant={false} toggleTask={toggleTask} deleteTask={deleteTask} updateTask={updateTask} toggleSubtask={toggleSubtask} deleteSubtask={deleteSubtask} updateSubtask={updateSubtask} addSubtask={addSubtask} reorderSubtask={reorderSubtask} addingSubtaskTo={addingSubtaskTo} setAddingSubtaskTo={setAddingSubtaskTo} onDragStart={onDragStart} onDragOver={onDragOver} onDropTask={onDropTask} onDropQuadrant={onDropQuadrant} draggedTaskId={draggedTaskId} draggedType={draggedType} />
                                    <Quadrant id="q4" title="Î≥ÑÎ°ú Ïïà Ï§ëÏöîÌï®" description="Î≥¥Í¥ÄÌï®" tasks={notUrgentNotImportant} headerColor="bg-slate-500 text-slate-500" icon={ListIcon} targetUrgent={false} targetImportant={false} toggleTask={toggleTask} deleteTask={deleteTask} updateTask={updateTask} toggleSubtask={toggleSubtask} deleteSubtask={deleteSubtask} updateSubtask={updateSubtask} addSubtask={addSubtask} reorderSubtask={reorderSubtask} addingSubtaskTo={addingSubtaskTo} setAddingSubtaskTo={setAddingSubtaskTo} onDragStart={onDragStart} onDragOver={onDragOver} onDropTask={onDropTask} onDropQuadrant={onDropQuadrant} draggedTaskId={draggedTaskId} draggedType={draggedType} />
                                </div>
                            ) : (
                                <div className="max-w-3xl mx-auto bg-white rounded-3xl shadow-sm border border-gray-100 overflow-hidden min-h-[500px]">
                                    <div className="flex border-b border-gray-50 overflow-x-auto px-2">
                                        {['all', 'active', 'completed'].map(tab => (
                                            <button key={tab} onClick={() => setActiveTab(tab)} className={`px-6 py-5 text-sm font-bold transition-all whitespace-nowrap relative ${activeTab === tab ? 'text-gray-900' : 'text-gray-400 hover:text-gray-600'}`}>{tab === 'all' ? 'Ï†ÑÏ≤¥' : tab === 'active' ? 'ÏßÑÌñâÏ§ë' : 'ÏôÑÎ£åÎê®'}{activeTab === tab && (<div className="absolute bottom-0 left-1/2 -translate-x-1/2 w-1 h-1 bg-black rounded-full mb-2" />)}</button>
                                        ))}
                                    </div>
                                    <div className="p-6 max-h-[70vh] overflow-y-auto custom-scrollbar">
                                        {tasks.filter(t => { if (activeTab === 'active') return !t.completed; if (activeTab === 'completed') return t.completed; return true; }).map(t => (
                                            <TaskItem key={t.id} task={t} toggleTask={toggleTask} deleteTask={deleteTask} updateTask={updateTask} toggleSubtask={toggleSubtask} deleteSubtask={deleteSubtask} updateSubtask={updateSubtask} addSubtask={addSubtask} reorderSubtask={reorderSubtask} addingSubtaskTo={addingSubtaskTo} setAddingSubtaskTo={setAddingSubtaskTo} onDragStart={onDragStart} onDragOver={onDragOver} onDropTask={onDropTask} isDraggingSource={draggedTaskId === t.id} draggedType={draggedType} />
                                        ))}
                                        {tasks.length === 0 && <div className="py-20 text-center"><div className="inline-flex items-center justify-center w-12 h-12 rounded-full bg-gray-50 mb-3"><ListIcon className="w-5 h-5 text-gray-300" /></div><p className="text-gray-400 text-sm">Ìï† ÏùºÏù¥ ÏóÜÏäµÎãàÎã§.</p></div>}
                                    </div>
                                </div>
                            )}
                        </div>
                    </main>
                </div>
            );
        };

        const root = createRoot(document.getElementById('root'));
        root.render(<FocusFlowApp />);
    </script>
</body>
</html>
